演示5.2：缺页故障
分析对象：版本0内核

本实验用到的命令汇总：
--------------------------------------------------------------
nudt@uvm:~/os/linux-0.11-lab$ ./rundbg
(gdb) b do_no_page
(gdb) c
(gdb) p/x address
(gdb) bt
(gdb) p 0x8000000>>22
(gdb) x/33wx 0
(gdb) list
(gdb) 
(gdb) 
(gdb) 
(gdb) b 381
(gdb) b 387
(gdb) b 394
(gdb) c
(gdb) n
(gdb) p/x page
(gdb) x/64hx 0xffa000
(gdb) c
(gdb) n
(gdb) x/64hx 0xffa000
(gdb) c
(gdb) x/33wx 0
(gdb) n
(gdb) x/33wx 0
(gdb) x/wx 0xff7000
(gdb) x/64hx 0x8000000
(gdb) kill
(gdb) quit


文件~/os/linux-0.11-lab/0.gdb的内容：
--------------------------------------------------------------
target remote localhost:1234
handle SIGSEGV nostop noprint ignore
b main
display current->pid
c


调试过程：
--------------------------------------------------------------
nudt@uvm:~/os/linux-0.11-lab/0/linux$ gdb tools/system -x ../../0.gdb
GNU gdb (GDB) 7.6.1-ubuntu
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>...
Reading symbols from /mnt/hgfs/u/os-exp/20spring-os/linux-0.11-lab/0/linux/tools/system...done.
0x0000fff0 in find_entry (dir=0x0 <startup_32>, name=0x0 <startup_32>, 
    namelen=0, res_dir=0x0 <startup_32>) at namei.c:149
149			i++;
Breakpoint 1 at 0x6799: file init/main.c, line 105.

Breakpoint 1, main () at init/main.c:105
105	{			/* The startup routine assumes (well, ...) this */
1: current->pid = 0

//跟踪到第一次缺页故障
(gdb) b do_no_page
Breakpoint 2 at 0xace7: file memory.c, line 367.

(gdb) c
Continuing.

Breakpoint 2, do_no_page (error_code=4, address=134217728) at memory.c:367
367	{
1: current->pid = 2
  此故障由2号进程引发，该进程的用户线性地址空间是[128M, 192M)，即[0x8000000,0xc000000)。

//查看引发页故障的线性地址
(gdb) p/x address
$1 = 0x8000000
  可见是在此进程的用户虚空间的起始位置，这里一般放的是对应可执行文件的内容（0号和1号进程除外）。

(gdb) bt
#0  do_no_page (error_code=4, address=134217728) at memory.c:367
#1  0x0000afd7 in page_fault ()
#2  0x00000004 in startup_32 ()
  可见当前处于页故障处理程序的内核控制流，且本页故障是由缺页引发。

//查看地址0x8000000对应的页目录项
(gdb) p 0x8000000>>22
$2 = 32

(gdb) x/33wx 0
0x0 <startup_32>:	0x00001027	0x00002007	0x00003007	0x00004027
0x10 <startup_32+16>:	0x00000000	0x00023c54	0x00000000	0x00000000
0x20 <startup_32+32>:	0x00000000	0x00000000	0x00000000	0x00000000
0x30 <startup_32+48>:	0x00000000	0x00000000	0x00000000	0x00000000
0x40 <startup_32+64>:	0x00ffe027	0x00000000	0x00000000	0x00000000
0x50 <startup_32+80>:	0x00000000	0x00000000	0x00000000	0x00000000
0x60 <check_x87+6>:	0x00000000	0x00000000	0x00000000	0x00000000
0x70 <check_x87+22>:	0x00000000	0x00000000	0x00000000	0x00000000
0x80 <setup_idt+13>:	0x00000000
  可见32号页目录项当前为全0，说明不存在对应的二级页表和页帧。

//查看内核源码
(gdb) list
362		}
363		return 0;
364	}
365	
366	void do_no_page(unsigned long error_code,unsigned long address)
367	{
368		int nr[4];
369		unsigned long tmp;
370		unsigned long page;
371		int block,i;
(gdb) 
372	
373		address &= 0xfffff000;
374		tmp = address - current->start_code;
375		if (!current->executable || tmp >= current->end_data) {
376			get_empty_page(address);
377			return;
378		}
379		if (share_page(tmp))
380			return;
381		if (!(page = get_free_page()))
(gdb) 
382			oom();
383	/* remember that 1 block is used for header */
384		block = 1 + tmp/BLOCK_SIZE;
385		for (i=0 ; i<4 ; block++,i++)
386			nr[i] = bmap(current->executable,block);
387		bread_page(page,current->executable->i_dev,nr);
388		i = tmp + 4096 - current->end_data;
389		tmp = page + 4096;
390		while (i-- > 0) {
391			tmp--;
(gdb) 
392			*(char *)tmp = 0;
393		}
394		if (put_page(page,address))
395			return;
396		free_page(page);
397		oom();
398	}
399	
400	void mem_init(long start_mem, long end_mem)
401	{
  其中381行申请空闲页帧，387行读入文件数据，394行修改页表项。

//在这三行设置断点
(gdb) b 381
Breakpoint 3 at 0xad4f: file memory.c, line 381.

(gdb) b 387
Breakpoint 4 at 0xadac: file memory.c, line 387.

(gdb) b 394
Breakpoint 5 at 0xae1a: file memory.c, line 394.

//跟踪分析申请到的空闲页帧
(gdb) c
Continuing.

Breakpoint 3, do_no_page (error_code=4, address=134217728) at memory.c:381
381		if (!(page = get_free_page()))
1: current->pid = 2

(gdb) n
384		block = 1 + tmp/BLOCK_SIZE;
1: current->pid = 2

//查看申请到的空闲页帧的地址
(gdb) p/x page
$3 = 0xffa000

(gdb) x/64hx 0xffa000
0xffa000:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
0xffa010:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
0xffa020:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
0xffa030:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
0xffa040:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
0xffa050:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
0xffa060:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
0xffa070:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
  此时该页帧的内容为全0。

//跟踪分析文件数据的读入
(gdb) c
Continuing.

Breakpoint 4, do_no_page (error_code=4, address=134217728) at memory.c:387
387		bread_page(page,current->executable->i_dev,nr);
1: current->pid = 2

(gdb) n
388		i = tmp + 4096 - current->end_data;
1: current->pid = 2

(gdb) x/64hx 0xffa000
0xffa000:	0x448b	0x0824	0x00a3	0x02f0	0xe800	0x0126	0x0000	0x006a
0xffa010:	0x37e8	0x028c	0xeb00	0x00f9	0x7355	0x7265	0x0020	0x6162
0xffa020:	0x6873	0x245c	0x0020	0x6162	0x6873	0x003e	0x2f7e	0x622e
0xffa030:	0x7361	0x7268	0x0063	0x6564	0x7562	0x0067	0x6f6e	0x6372
0xffa040:	0x6e00	0x706f	0x6f72	0x6966	0x656c	0x7200	0x6663	0x6c69
0xffa050:	0x0065	0x6576	0x7372	0x6f69	0x006e	0x7571	0x6569	0x0074
0xffa060:	0x6f6c	0x6967	0x006e	0x6f6e	0x696c	0x656e	0x6465	0x7469
0xffa070:	0x6e69	0x0067	0x6f6e	0x7262	0x6361	0x6565	0x7078	0x6e61
  此时该页帧已经填满文件数据，这些数据来自于文件sh。

//{可如下验证文件sh的内容
nudt@uvm:~/os/linux-0.11-lab/tmp$ hexdump sh | less
0000000 010b 0000 f000 0002 3000 0000 12a8 0000
0000010 0000 0000 0000 0000 0000 0000 0000 0000
*
0000400 448b 0824 00a3 02f0 e800 0126 0000 006a
0000410 37e8 028c eb00 00f9 7355 7265 0020 6162
0000420 6873 245c 0020 6162 6873 003e 2f7e 622e
0000430 7361 7268 0063 6564 7562 0067 6f6e 6372
0000440 6e00 706f 6f72 6966 656c 7200 6663 6c69
0000450 0065 6576 7372 6f69 006e 7571 6569 0074
0000460 6f6c 6967 006e 6f6e 696c 656e 6465 7469
0000470 6e69 0067 6f6e 7262 6361 6565 7078 6e61
  其中第一块（1K）为文件头，从第二块开始为sh的代码段。
//}

//跟踪分析对页表项的修改
(gdb) c
Continuing.

Breakpoint 5, do_no_page (error_code=4, address=134217728) at memory.c:394
394		if (put_page(page,address))
1: current->pid = 2

(gdb) x/33wx 0
0x0 <startup_32>:	0x00001027	0x00002007	0x00003007	0x00004027
0x10 <startup_32+16>:	0x00000000	0x00023ce4	0x00000000	0x00000000
0x20 <startup_32+32>:	0x00000000	0x00000000	0x00000000	0x00000000
0x30 <startup_32+48>:	0x00000000	0x00000000	0x00000000	0x00000000
0x40 <startup_32+64>:	0x00ffe027	0x00000000	0x00000000	0x00000000
0x50 <startup_32+80>:	0x00000000	0x00000000	0x00000000	0x00000000
0x60 <check_x87+6>:	0x00000000	0x00000000	0x00000000	0x00000000
0x70 <check_x87+22>:	0x00000000	0x00000000	0x00000000	0x00000000
0x80 <setup_idt+13>:	0x00000000
  此时页目录项依然是空。

//修改
(gdb) n
395			return;
1: current->pid = 2

//查看新的页目录项
(gdb) x/33wx 0
0x0 <startup_32>:	0x00001027	0x00002007	0x00003007	0x00004027
0x10 <startup_32+16>:	0x00000000	0x00023ce4	0x00000000	0x00000000
0x20 <startup_32+32>:	0x00000000	0x00000000	0x00000000	0x00000000
0x30 <startup_32+48>:	0x00000000	0x00000000	0x00000000	0x00000000
0x40 <startup_32+64>:	0x00ffe027	0x00000000	0x00000000	0x00000000
0x50 <startup_32+80>:	0x00000000	0x00000000	0x00000000	0x00000000
0x60 <check_x87+6>:	0x00000000	0x00000000	0x00000000	0x00000000
0x70 <check_x87+22>:	0x00000000	0x00000000	0x00000000	0x00000000
0x80 <setup_idt+13>:	0x00ff7007
  32号页目录项已改，指向了二级页表0xff7000。

//查看对应的页表
(gdb) x/wx 0xff7000
0xff7000:	0x00ffa007
  此为0号页表项，对应于地址0x8000000（中间10位为0）。已被设置好，指向了前面新申请的页帧0xffa。

//查看线性地址0x8000000所在页面的内容
(gdb) x/64hx 0x8000000
0x8000000:	0x448b	0x0824	0x00a3	0x02f0	0xe800	0x0126	0x0000	0x006a
0x8000010:	0x37e8	0x028c	0xeb00	0x00f9	0x7355	0x7265	0x0020	0x6162
0x8000020:	0x6873	0x245c	0x0020	0x6162	0x6873	0x003e	0x2f7e	0x622e
0x8000030:	0x7361	0x7268	0x0063	0x6564	0x7562	0x0067	0x6f6e	0x6372
0x8000040:	0x6e00	0x706f	0x6f72	0x6966	0x656c	0x7200	0x6663	0x6c69
0x8000050:	0x0065	0x6576	0x7372	0x6f69	0x006e	0x7571	0x6569	0x0074
0x8000060:	0x6f6c	0x6967	0x006e	0x6f6e	0x696c	0x656e	0x6465	0x7469
0x8000070:	0x6e69	0x0067	0x6f6e	0x7262	0x6361	0x6565	0x7078	0x6e61
  可见就是页帧0xffa的内容（页面0x8000映射到了页帧0xffa）。

(gdb) kill
Kill the program being debugged? (y or n) y

(gdb) quit
